# Model design
import agentpy as ap

# Visualization
import matplotlib.pyplot as plt
import seaborn as sns
import IPython

import random

start_x, end_x = 0, 50
y_position = 25
horizontal_positions = [(x, y_position) for x in range(start_x, end_x)]
vertical_positions = [(25, x) for x in range(start_x, end_x)]
positions = horizontal_positions + vertical_positions


random_goal_position = random.choice(positions)
print("random_goal_position : ", random_goal_position)

class MovingAgent(ap.Agent):
    def setup(self):
        self.position = (25, 0)  # Starting position
        self.goal = random_goal_position    # Goal position
        self.path = positions
        # self.condition = 1

    def move(self):
        # Define movement logic here to move towards the goal
        # Ensure movement is within allowed positions
        # If goal is reached, stop the model
        if self.position == self.goal:
            self.model.stop()
        else:
            # Example movement: move closer to the goal
            x, y = self.position
            goal_x, goal_y = self.goal

            # Move in the x direction
            if x < goal_x and (x + 1, y) in self.path:
                x += 1
            elif x > goal_x and (x - 1, y) in self.path:
                x -= 1

            # Move in the y direction
            if y < goal_y and (x, y + 1) in self.path:
                y += 1
            elif y > goal_y and (x, y - 1) in self.path:
                y -= 1

            self.position = (x, y)

#! specific position on the grid, you should use self.forest.agents[position]
#* ‡∏Ñ‡∏≠‡∏°‡πÄ‡∏°‡∏ô‡∏ó‡πå‡∏™‡∏µ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß‡∏´‡∏°‡∏≤‡∏¢‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ß‡πà‡∏≤‡πÄ‡∏Ñ‡∏¢‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô ‡πÅ‡∏ï‡πà‡πÄ‡∏≠‡∏≤‡∏≠‡∏≠‡∏Å‡πÑ‡∏õ‡πÅ‡∏•‡πâ‡∏ß
#TODO ‡∏Ñ‡∏≠‡∏°‡πÄ‡∏°‡∏ô‡∏ó‡πå‡∏™‡∏µ‡∏™‡πâ‡∏°‡∏Ñ‡∏∑‡∏≠ ‡∏ó‡∏≥‡∏†‡∏≤‡∏¢‡πÉ‡∏ô‡∏≠‡∏ô‡∏≤‡∏Ñ‡∏ï
#? ‡∏Ñ‡∏≠‡∏°‡πÄ‡∏°‡∏ô‡∏ó‡πå‡∏™‡∏µ‡∏ü‡πâ‡∏≤‡πÄ‡∏≠‡∏≤‡πÑ‡∏ß‡πâ‡∏ö‡∏≠‡∏Å‡∏™‡πà‡∏ß‡∏ô‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡πÄ‡∏â‡∏¢‡πÜ
# ‡∏Ñ‡∏≠‡∏°‡πÄ‡∏°‡∏ô‡∏ó‡πå‡∏™‡∏µ‡πÄ‡∏ó‡∏≤ ‡πÑ‡∏ß‡πâ‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡πÄ‡∏â‡∏¢

def manhattan_distance(point1, point2):
    return abs(point1[0] - point2[0]) + abs(point1[1] - point2[1])


class Road(ap.Agent):
    def setup(self):
        # `position` ‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡∏∏‡∏ì‡∏™‡∏°‡∏ö‡∏±‡∏ï‡∏¥‡∏Ç‡∏≠‡∏á‡πÄ‡∏≠‡πÄ‡∏¢‡∏ô‡∏ï‡πå
        self.position = None


class ForestModel(ap.Model):

    def setup(self):

        # Create agents (trees)
        #* n_trees = int(self.p['Tree density'] * (self.p.size**2))
        n_trees = 100
        roads = self.roads = ap.AgentList(self, n_trees , Road) # ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ï‡∏±‡∏ß‡πÅ‡∏ó‡∏ô n_trees ‡∏ï‡∏±‡∏ß



        # Create grid (forest) ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Å‡∏£‡∏¥‡∏î‡∏Ç‡∏ô‡∏≤‡∏î 50*50
        self.map = ap.Grid(self, [self.p.size]*2, track_empty=True) # https://agentpy.readthedocs.io/en/latest/reference_grid.html#agentpy.Grid
        # ‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏°‡∏µ 1500 ‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏ö‡∏ô‡πÅ‡∏°‡∏û‡∏°‡∏µ 2500 (50*50)


        # TODO ‡∏ó‡∏≥ Position
        # position ‡πÄ‡∏õ‡πá‡∏ô array --> [(0, 25), (1, 25) , ...] 
        # ‡πÄ‡∏≠‡∏≤‡πÑ‡∏ß‡πâ‡πÉ‡∏´‡πâ‡∏£‡∏π‡πâ‡∏ß‡πà‡∏≤ ‡∏ñ‡πâ‡∏≤‡∏≠‡∏¢‡∏≤‡∏Å‡∏ü‡∏¥‡∏Å‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á agent ‡∏ï‡∏±‡∏ß‡∏ó‡∏µ‡πà 50 ‡∏°‡∏±‡∏ô‡∏ó‡∏≥‡πÑ‡∏á
        # positions = [(i % 50, i // 50) for i in range(2500)]
        # positions[50] = (2, 8)


        self.map.add_agents(roads, positions=positions, empty=True) # https://agentpy.readthedocs.io/en/latest/reference_environments.html

        #? Initialize conditions 
        self.roads.condition = 0
        # condition ‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏Ñ‡∏∏‡∏ì‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÉ‡∏´‡πâ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏Ç‡∏≠‡∏á‡πÄ‡∏≠‡πÄ‡∏¢‡∏ô‡∏ï‡πå 
        # condition ‡∏Ç‡∏≠‡∏á‡πÄ‡∏≠‡πÄ‡∏¢‡∏ô‡∏ï‡πå‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÉ‡∏ô self.roads ‡πÄ‡∏õ‡πá‡∏ô 0 ‡πÅ‡∏ï‡πà‡∏ñ‡πâ‡∏≤‡πÄ‡∏≠‡πÄ‡∏¢‡∏ô‡∏ï‡πå‡πÉ‡∏î‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô self.roads ‡∏°‡∏±‡∏ô‡∏à‡∏∞‡∏°‡∏µ‡∏Ñ‡πà‡∏≤ None




        #? Define positions
        # self.positions = positions
        self.map.add_agents(roads, positions=positions, empty=True) # add Road Agent
        for road, pos in zip(self.roads, positions):
            road.position = pos
            # -->  Road (Obj 1) pos : (0, 25)
        # for agent in self.map.agents:
        #     print(f"agent {agent.position} condition : {agent.condition}")
        # agent (0, 25) condition : 0


        #? Define function to get agents at specific positions
        # def get_agents_at_position(grid, position):
        #     return [agent for agent in grid.agents if grid.positions[agent] == position]

        
        #? Create a MovingAgent 
        bicycle = self.bicycle = ap.AgentList(self, 1, MovingAgent)
        self.map.add_agents(bicycle, positions=bicycle.position)
        self.bicycle.condition = 3

        
        #? Set Goal
        reachTarget = self.map.agents[random_goal_position]  # Access agents at position (10, 25)
        # reachTarget ‡πÄ‡∏õ‡πá‡∏ô GridIter 
        print(f"reachTarget: {reachTarget}")
        if reachTarget:  # Check if any agents exist at that position
            for agent in reachTarget:  # Loop through agents and update condition
                print(f"agent : {agent}")
                if isinstance(agent, Road):
                    agent.condition = 4
        else:
            print("No agent found at (10, 25)")

        # reachTarget: GridIter (2 objects)
        # agent : Road (Obj 51)
        # agent : MovingAgent (Obj 102)


        # print("self.map.agents : ",  self.map.agents) # GridIter (101 objects)

        

        print("----------------------- end setup")

    def update(self):
        """ Record variables after setup and each step. """    

    def step(self):

        # Select burning trees
        #* burning_trees = self.agents.select(self.agents.condition == 1) # ‡∏°‡∏µ AgentList (0 objects) ‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ‡∏á‡∏µ‡πâ ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡πÄ‡∏£‡∏≤‡πÑ‡∏°‡πà‡πÉ‡∏™‡πà condition 1 ‡∏•‡∏á‡πÑ‡∏õ
        # for tree in burning_trees:
        #     for neighbor in self.forest.neighbors(tree):

        

        # class AgentList ‡∏ó‡∏±‡πâ‡∏á‡∏™‡∏≠‡∏á‡∏ï‡∏±‡∏ß
        find_bike = self.bicycle.select(self.bicycle.condition == 3) # ‡∏°‡∏µ AgentList (1 object)
        start = self.roads.select(self.roads.position == find_bike.position[0])  # Find the starting position
        all_path = []
        # print(f" find_bike.position : {find_bike.position}")
        for gridRoad in start:
            # gridRoad class Road
            for neighbor in self.map.neighbors(gridRoad):
                all_path.append(neighbor.position)
                # print(neighbor.position) ‡∏°‡∏µ 2 ‡∏ï‡∏±‡∏ß‡∏Ñ‡∏∑‡∏≠ (25,0) and (25,1)
                # if neighbor.position == gridRoad.position:
                #     continue
                # else:
                #     # self.map.move_by(find_bike, neighbor.position)
                #     self.bicycle[0].position = neighbor.position
                #     print(f" find_bike.position ‡∏´‡∏•‡∏±‡∏á move : {find_bike.position}")
                #     break; # break‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô‡∏ö‡πâ‡∏≤‡∏ô‡∏°‡∏µ‡∏´‡∏•‡∏≤‡∏¢‡∏≠‡∏±‡∏ô ‡πÅ‡∏ï‡πà‡πÄ‡∏£‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏ô‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡πÅ‡∏•‡πâ‡∏ß‡∏à‡∏ö‡πÄ‡∏•‡∏¢
        
        
        closest_path = None
        min_distance = float('inf')  # ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏Ñ‡πà‡∏≤‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÄ‡∏õ‡πá‡∏ô‡∏≠‡∏ô‡∏±‡∏ô‡∏ï‡πå
        # print(all_path) # [(25, 0), (25, 1)]
        for path in all_path:
            distance = manhattan_distance(path, random_goal_position)
            if distance < min_distance:
                min_distance = distance
                closest_path = path
                # print(f"The closest path to {random_goal_position} is {closest_path} with a distance of {min_distance}.")

        print(closest_path)
        self.bicycle[0].position = closest_path


        # Concept
        # for ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏à‡∏∏‡∏î‡∏´‡∏ô‡∏∂‡πà‡∏á‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏à‡∏±‡∏Å‡∏£‡∏¢‡∏≤‡∏ô‡∏≠‡∏¢‡∏π‡πàgridRoad(Agent) in ‡∏ñ‡∏ô‡∏ô‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏îRoads(AgentList)
        #     for ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô‡∏ö‡πâ‡∏≤‡∏ô‡∏Ç‡∏≠‡∏á‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏Å‡∏£‡∏¥‡∏î‡∏ñ‡∏ô‡∏ô‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏à‡∏±‡∏Å‡∏£‡∏¢‡∏≤‡∏ô‡∏≠‡∏¢‡∏π‡πà in ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô‡∏ö‡πâ‡∏≤‡∏ô‡∏Ç‡∏≠‡∏ágridRoad(AgentIter)
        #         # ‡∏°‡∏±‡∏ô‡∏à‡∏∞‡∏°‡∏µ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô‡∏ö‡πâ‡∏≤‡∏ô 4 ‡∏ó‡∏¥‡∏® ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç
        #         ‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ï‡∏±‡∏ß‡πÄ‡∏≠‡∏á:
        #             continue
        #         moving
            
            


        
        # print("start : ",start) # ‚Å°‚Å¢‚Å¢‚Å£ensure that start refers to a single agent, not an AgentList or collection of agents‚Å°
        # start :  AgentList (1 object)
        # print(" start[0]", start.position) # --> [(25, 0)]
        # print(" start[0]", start) # --> Road (Obj 51) -- ‡πÄ‡∏≠‡πÄ‡∏¢‡∏ô‡∏ï‡πå Road ‡∏ô‡∏µ‡πâ‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏≠‡πÄ‡∏¢‡∏ô‡∏ï‡πå‡∏ó‡∏µ‡πà 51 ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡∏∂‡πâ‡∏ô
        # print(f"type : {type(start)}") # --> AgentList
        # for road in self.roads:
        #     print(road.position)

        # burning_trees = self.agents.select(self.agents.condition == 1)
        # road_path = self.roads.select(self.roads.condition == 0)
        # for road in self.roads:
        #     print(type(road))




        # # !!!! ‡∏à‡∏∞‡∏Å‡∏•‡∏±‡∏ö‡∏°‡∏≤‡∏ó‡∏≥ step ‡∏ï‡πà‡∏≠ üëÄüëÄüëÄ !!!!
        # for agent_bike in find_bike:
        #     neighbors = self.map.neighbors(start) # ‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏õ‡πá‡∏ô AgentIter
        #     for neighbor in neighbors:
        #         print(neighbor)



            #     print("neighbor.condition == 0 " , neighbor)
            #     if neighbor.position == agent_bike.position:
            #         print("continue üå∂Ô∏è")
            #         continue

                
            #     # Move agent to neighbor if condition == 4
            #     if neighbor.condition == 4:
            #         self.map.move_by(agent_bike, neighbor.position)
            #         self.stop()
            #         break
            #     # elif neighbor.condition == 0 and neighbor.position != agent_bike.position:
            #     # #     #TODO ‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏™‡∏ô‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ñ‡∏≠‡∏¢‡∏´‡∏•‡∏±‡∏á‡∏´‡∏£‡∏∑‡∏≠‡∏´‡∏ô‡πâ‡∏≤ ‡πÅ‡∏Ñ‡πà‡∏Ç‡∏¢‡∏±‡∏ö‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏ï‡∏£‡∏á‡∏ó‡∏µ‡πà‡∏°‡∏±‡∏ô‡∏≠‡∏¢‡∏π‡πà‡∏Å‡πà‡∏≠‡∏ô --> ‡πÑ‡∏õ‡∏ó‡∏≥‡∏ï‡πà‡∏≠‡πÉ‡∏ô‡∏≠‡∏ô‡∏≤‡∏Ñ‡∏ï
            #     #     print("‡∏Å‡πà‡∏≠‡∏ô move", agent_bike.position[0])
            #     #     self.map.move_by(agent_bike, neighbor.position)
            #     #     print("‡∏´‡∏•‡∏±‡∏á move", agent_bike.position[0])
            #     #     # ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç position ‡∏Ç‡∏≠‡∏á bike ‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡πÉ‡∏´‡∏°‡πà
            #     # #     neighbor.condition = 3
            #     elif neighbor.condition == 0 and neighbor.position != agent_bike.position:
            #         # ‡∏Ç‡∏¢‡∏±‡∏ö‡∏à‡∏±‡∏Å‡∏£‡∏¢‡∏≤‡∏ô
            #         print("ìÜù ìÜü ìÜû ìÜù ìÜü")
            #         print("Before move", agent_bike.position)
            #         self.map.move_by(agent_bike, neighbor.position)
            #         # print(f"Neighbors of agent at position {neighbor.position} condition is : {neighbor.condition}") # ‡∏°‡∏±‡∏ô‡πÑ‡∏î‡πâ 2 ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡πÑ‡∏î‡πâ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á (25, 0) ‡∏Å‡∏±‡∏ö (25, 1)  ‡∏Ñ‡∏∑‡∏≠‡∏°‡∏±‡∏ô‡∏ô‡∏±‡∏ö‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡∏°‡∏±‡∏ô‡∏î‡πâ‡∏ß‡∏¢‡∏≠‡∏∞
                    
            #         # ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏à‡∏±‡∏Å‡∏£‡∏¢‡∏≤‡∏ô
            #         agent_bike.position = neighbor.position 
            #         print("After move", agent_bike.position)
            #         print("ìÜù ìÜü ìÜû ìÜù ìÜü")

            #         # ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô condition 3 ‡πÉ‡∏´‡πâ‡πÄ‡∏ó‡πà‡∏≤‡∏Å‡∏±‡∏ö‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡πÉ‡∏´‡∏°‡πà


        if self.t == 10:
            self.stop()


        
        # move_next = self.forest.neighbors(self.bicycle)
        # print(mo)
        # grid.move_agent(agents[agent_index], target_position)


        # Spread fire
        # for tree in burning_trees:
        #     for neighbor in self.forest.neighbors(tree):
        #         # attribute position ‡∏à‡∏∞‡∏°‡∏µ‡πÅ‡∏Ñ‡πà‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏≤‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏•‡∏á‡πÉ‡∏´‡πâ ‡∏Ñ‡∏∑‡∏≠ goal ‡∏Å‡∏±‡∏ö ‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô
        #         if neighbor.condition == 0:
        #             neighbor.condition = 1 # Neighbor starts burning
        #     tree.condition = 2 # Tree burns out
        #     # print(f"------------------ Step: {self.t} ------ {(len(self.forest.neighbors(tree)))}")

        # # Stop simulation if no fire is left
        # if len(burning_trees) == 0:
        #     self.stop()
        
        

        
        




    def end(self):

        # Document a measure at the end of the simulation
        # burned_trees = len(self.agents.select(self.agents.condition == 2))
        # self.report('Percentage of burned trees',
        #             burned_trees / len(self.agents))
        self.report("Bicycle Sharing")

        
        
parameters = {
    'Tree density': 0.2, # Percentage of grid covered by trees
    'size': 50, # Height and length of the grid
    'steps': 100,
}

# Create single-run animation with custom colors

def animation_plot(model, ax):
    attr_grid = model.map.attr_grid('condition') # attr_grid() ‡πÄ‡∏õ‡πá‡∏ô‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏Ñ‡πà‡∏≤‡πÅ‡∏≠‡∏ï‡∏ó‡∏£‡∏¥‡∏ö‡∏¥‡∏ß‡∏ï‡πå (attribute) ‡∏Ç‡∏≠‡∏á‡∏ï‡∏±‡∏ß‡πÅ‡∏ó‡∏ô‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÉ‡∏ô‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà grid ‡∏Ç‡∏≠‡∏á‡∏õ‡πà‡∏≤
    # ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏î‡πâ‡∏≤‡∏ô‡∏ö‡∏ô attr_grid ‡∏î‡πâ‡∏≤‡∏ô‡∏ö‡∏ô ‡∏à‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á grid (‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà) ‡∏Ç‡∏≠‡∏á‡∏õ‡πà‡∏≤‡∏ó‡∏µ‡πà‡πÅ‡∏™‡∏î‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Ç‡∏≠‡∏á‡∏ï‡∏±‡∏ß‡πÅ‡∏ó‡∏ô (agents) ‡∏ó‡∏∏‡∏Å‡∏ï‡∏±‡∏ß ‡πÇ‡∏î‡∏¢‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å‡πÅ‡∏≠‡∏ï‡∏ó‡∏£‡∏¥‡∏ö‡∏¥‡∏ß‡∏ï‡πå condition ‡∏Ç‡∏≠‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏ï‡∏±‡∏ß‡πÅ‡∏ó‡∏ô‡πÅ‡∏•‡∏∞‡∏à‡∏±‡∏î‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö grid
    # A two-dimensional grid (‡∏Å‡∏£‡∏¥‡∏î‡∏™‡∏≠‡∏á‡∏°‡∏¥‡∏ï‡∏¥) ‡∏Ñ‡∏∑‡∏≠‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏£‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡∏£‡∏∑‡∏≠‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏ï‡πà‡∏≤‡∏á‡πÜ ‡∏•‡∏á‡πÉ‡∏ô‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏Ç‡∏≠‡∏á‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏™‡∏≠‡∏á‡∏°‡∏¥‡∏ï‡∏¥‚Äî‡∏°‡∏¥‡∏ï‡∏¥‡πÅ‡∏ñ‡∏ß‡πÅ‡∏•‡∏∞‡∏°‡∏¥‡∏ï‡∏¥‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå ‡πÇ‡∏î‡∏¢‡∏ó‡∏±‡πà‡∏ß‡πÑ‡∏õ‡πÅ‡∏•‡πâ‡∏ß‡∏à‡∏∞‡∏°‡∏µ‡∏•‡∏±‡∏Å‡∏©‡∏ì‡∏∞‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏ó‡∏µ‡πà‡πÅ‡∏ö‡πà‡∏á‡∏≠‡∏≠‡∏Å‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏ã‡∏•‡∏•‡πå (cells) ‡∏ó‡∏µ‡πà‡πÅ‡∏ï‡πà‡∏•‡∏∞‡πÄ‡∏ã‡∏•‡∏•‡πå‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡∏£‡∏∑‡∏≠‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡πÑ‡∏î‡πâ
    
    # 0 ‡∏Ñ‡∏∑‡∏≠ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô ‡∏ô‡πâ‡∏≥‡πÄ‡∏á‡∏¥‡∏ô‡∏ô‡∏ô‡∏ô ‡∏Ñ‡∏∑‡∏≠‡∏ñ‡∏ô‡∏ô ,1 ‡∏Ñ‡∏∑‡∏≠‡∏ñ‡∏ô‡∏ô ‡∏î‡∏≥‡∏≥‡∏≥,  2 ‡∏Ñ‡∏∑‡∏≠‡πÄ‡∏õ‡πá‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏µ‡πà‡πÄ‡∏î‡∏¥‡∏ô‡πÅ‡∏•‡πâ‡∏ß ‡∏ä‡∏°‡∏û‡∏π , None ‡∏Ñ‡∏∑‡∏≠‡∏™‡∏µ‡∏ô‡πâ‡∏≥‡∏ï‡∏≤‡∏• ,3 ‡∏Ñ‡∏∑‡∏≠ actor or bicycle , 4 ‡∏Ñ‡∏∑‡∏≠ goal , '#d5e5d5' ‡∏´‡∏£‡∏∑‡∏≠ None ‡∏≠‡∏±‡∏ô‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏õ‡πá‡∏ô‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡∏ñ‡∏ô‡∏ô
    color_dict = {0:'#0000FF',  2:'#ff00fb', None:'#402b2f' , 3:"#aa7eee", 4:'#ffeb00'}
    ap.gridplot(attr_grid, ax=ax, color_dict=color_dict, convert=True) # https://agentpy.readthedocs.io/en/latest/reference_visualization.html
    ax.set_title(f"Simulation\n"
                 f"Time-step: {model.t}"
                #  f"Trees left: {len(model.agents.select(model.agents.condition == 0))}"
                )

fig, ax = plt.subplots()
model = ForestModel(parameters)
animation = ap.animate(model, fig, ax, animation_plot)
IPython.display.HTML(animation.to_jshtml(fps=15))
